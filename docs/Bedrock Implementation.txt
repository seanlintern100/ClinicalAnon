## **COMPLETE IMPLEMENTATION PLAN FOR AI CODER**
### **Secure AWS Bedrock Integration with Context Management**

---

## **Architecture Overview**

```
[Window 1: Original]  [Window 2: De-identified]  [Window 3: Final]
      â†“                        â†“                        â†‘
   User Paste              Auto-populate              Auto-populate
                                â†“                        â†‘
                    [Validate Redaction]                â†‘
                                â†“                        â†‘
                    [Security Warning]                  â†‘
                                â†“                        â†‘
                    [Send to Claude â†’ Sydney only]      â†‘
                         (TLS 1.2+ encrypted)           â†‘
                                â†“                        â†‘
                         [Modal with Chat]              â†‘
                                â†“                        â†‘
                    Conversation history                â†‘
                    builds in modal                     â†‘
                                â†“                        â†‘
                         User clicks Accept             â†‘
                                â†“                        â†‘
                    [Validate codes preserved]          â†‘
                                â†“                        â†‘
                         Re-identify codes              â†‘
                                â†“                        â†‘
                    Close modal & populate Window 3 â”€â”€â”€â”€â”˜
```

**Security Principles:**
- De-identification happens locally BEFORE encryption
- Only redacted text transmitted (encrypted via TLS 1.2+)
- Processing locked to AWS Sydney (ap-southeast-2)
- No persistent storage beyond Keychain credentials
- All session data in memory only (cleared on app close)

---

## **STEP 1: Data Models & Session Management**

### **1.1: Create ClaudeMessage Model**
```swift
// Models/ClaudeMessage.swift

struct ClaudeMessage: Codable {
    enum Role: String, Codable {
        case user
        case assistant
    }
    
    let role: Role
    let content: String
    let timestamp: Date
    
    init(role: Role, content: String) {
        self.role = role
        self.content = content
        self.timestamp = Date()
    }
}
```

### **1.2: Create DocumentType Enum**
```swift
// Models/DocumentType.swift

enum DocumentType: String, CaseIterable {
    case clinicalNotes = "Clinical Notes Organization"
    case reportWriting = "Report Writing Improvement"
    case synthesis = "Document Synthesis"
    case custom = "Custom Prompt"
    
    var systemPrompt: String {
        let basePrompt = """
        You are assisting with clinical documentation for a New Zealand psychology and wellbeing organization.
        
        Text has been de-identified using codes like [PERSON_A], [ORG_B], [LOCATION_C], [DATE_1].
        CRITICAL: Preserve these codes EXACTLY in all output. Never replace or modify them.
        
        Maintain clinical accuracy and professional tone appropriate for NZ health sector.
        Use te reo MÄori appropriately where relevant.
        """
        
        switch self {
        case .clinicalNotes:
            return basePrompt + "\n\nOrganize rough clinical notes into clear, structured format."
        case .reportWriting:
            return basePrompt + "\n\nImprove report clarity and professionalism while maintaining all clinical content."
        case .synthesis:
            return basePrompt + "\n\nSummarize and synthesize the provided documents."
        case .custom:
            return basePrompt + "\n\nFollow the user's custom instructions."
        }
    }
}
```

### **1.3: Create SessionManager**
```swift
// Managers/SessionManager.swift

@MainActor
class SessionManager: ObservableObject {
    static let shared = SessionManager()
    
    // Current session data (in-memory only - cleared on app close)
    @Published var originalText: String?
    @Published var deidentifiedText: String?
    @Published var entityMapping: EntityMapping?
    @Published var finalText: String?
    
    // Claude conversation
    @Published var conversationHistory: [ClaudeMessage] = []
    @Published var documentType: DocumentType?
    @Published var isDocumentTypeLocked: Bool = false
    @Published var userCustomInstructions: String = ""
    
    // Modal state
    @Published var isClaudeModalPresented: Bool = false
    @Published var isProcessing: Bool = false
    
    private init() {}
    
    func clearSession() {
        originalText = nil
        deidentifiedText = nil
        entityMapping = nil
        finalText = nil
        conversationHistory = []
        documentType = nil
        isDocumentTypeLocked = false
        userCustomInstructions = ""
        isClaudeModalPresented = false
        isProcessing = false
        
        SecurityLogger.shared.logSessionCleared()
    }
    
    func setDeidentifiedText(_ text: String, mapping: EntityMapping) {
        self.deidentifiedText = text
        self.entityMapping = mapping
    }
    
    func addMessage(role: ClaudeMessage.Role, content: String) {
        conversationHistory.append(ClaudeMessage(role: role, content: content))
    }
    
    func reidentify(text: String) -> String {
        guard let mapping = entityMapping else { return text }
        
        var result = text
        var swappedCount = 0
        
        // Reverse the mapping: [PERSON_A] â†’ "Wiremu"
        for (originalValue, placeholder) in mapping.mappings {
            let occurrences = result.components(separatedBy: placeholder).count - 1
            result = result.replacingOccurrences(of: placeholder, with: originalValue)
            swappedCount += occurrences
        }
        
        SecurityLogger.shared.logReidentification(placeholderCount: swappedCount)
        
        return result
    }
    
    // SECURITY: Validate redaction is complete before sending
    func validateRedactionComplete() throws {
        guard let deidentified = deidentifiedText,
              let mapping = entityMapping else {
            throw RedactionError.notRedacted
        }
        
        // Check that no original values appear in redacted text
        for (originalValue, _) in mapping.mappings {
            if deidentified.contains(originalValue) {
                throw RedactionError.incompleteRedaction(value: originalValue)
            }
        }
    }
    
    // SECURITY: Validate Claude preserved redaction codes
    func validateCodesPreserved(in text: String) throws {
        guard let mapping = entityMapping else {
            throw RedactionError.noMapping
        }
        
        // Check that at least some redaction codes are present
        let hasRedactionCodes = mapping.mappings.values.contains { placeholder in
            text.contains(placeholder)
        }
        
        if !hasRedactionCodes {
            throw RedactionError.codesNotPreserved
        }
    }
}

enum RedactionError: LocalizedError {
    case notRedacted
    case incompleteRedaction(value: String)
    case noMapping
    case codesNotPreserved
    
    var errorDescription: String? {
        switch self {
        case .notRedacted:
            return "Text must be de-identified before sending to Claude"
        case .incompleteRedaction(let value):
            return "Redaction incomplete: '\(value)' still appears in text. Please review de-identification."
        case .noMapping:
            return "No entity mapping available"
        case .codesNotPreserved:
            return "Claude's response doesn't contain redaction codes. Please try again."
        }
    }
}
```

---

## **STEP 2: User Preferences Storage**

### **2.1: Create PreferencesManager**
```swift
// Managers/PreferencesManager.swift

class PreferencesManager {
    static let shared = PreferencesManager()
    
    private let defaults = UserDefaults.standard
    
    // Keys - only non-sensitive preferences stored here
    private let userStyleKey = "userStylePreferences"
    
    // User style preferences (free text per document type)
    func getUserStyle(for documentType: DocumentType) -> String {
        let key = "\(userStyleKey)_\(documentType.rawValue)"
        return defaults.string(forKey: key) ?? ""
    }
    
    func setUserStyle(_ style: String, for documentType: DocumentType) {
        let key = "\(userStyleKey)_\(documentType.rawValue)"
        defaults.set(style, forKey: key)
    }
    
    func clearAllPreferences() {
        for type in DocumentType.allCases {
            let key = "\(userStyleKey)_\(type.rawValue)"
            defaults.removeObject(forKey: key)
        }
    }
}
```

---

## **STEP 3: Security & Logging**

### **3.1: Create SecurityLogger**
```swift
// Utilities/SecurityLogger.swift
import Foundation

class SecurityLogger {
    static let shared = SecurityLogger()
    
    private let dateFormatter: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        return formatter
    }()
    
    private func log(_ message: String) {
        let timestamp = dateFormatter.string(from: Date())
        print("ðŸ”’ [\(timestamp)] \(message)")
    }
    
    func logBedrockRequest(tokenCount: Int, documentType: String) {
        log("Bedrock request: \(documentType), ~\(tokenCount) tokens, region: ap-southeast-2")
        // DO NOT log actual content
    }
    
    func logBedrockResponse(tokenCount: Int, success: Bool) {
        log("Bedrock response: \(success ? "success" : "failure"), ~\(tokenCount) tokens")
        // DO NOT log actual content
    }
    
    func logReidentification(placeholderCount: Int) {
        log("Re-identification: \(placeholderCount) codes swapped")
        // DO NOT log actual values
    }
    
    func logSessionCleared() {
        log("Session cleared - all in-memory data purged")
    }
    
    func logSecurityWarningShown() {
        log("Security warning displayed to user")
    }
    
    func logSecurityWarningAccepted() {
        log("User accepted security warning - proceeding with encrypted transmission")
    }
    
    func logCredentialsSaved() {
        log("AWS credentials saved to Keychain")
    }
    
    func logCredentialsCleared() {
        log("AWS credentials cleared from Keychain")
    }
}
```

---

## **STEP 4: AWS Credentials Management**

### **4.1: Create AWSCredentialsManager (Keychain - Secure Storage)**
```swift
// Managers/AWSCredentialsManager.swift
import Security
import Foundation

class AWSCredentialsManager {
    static let shared = AWSCredentialsManager()
    
    private let accessKeyService = "com.yourapp.aws.accessKey"
    private let secretKeyService = "com.yourapp.aws.secretKey"
    
    // SECURITY: Region is locked to Sydney for NZ data residency
    private let lockedRegion = "ap-southeast-2"  // Sydney, Australia
    
    func saveCredentials(accessKey: String, secretKey: String) throws {
        // Save to Keychain (encrypted by macOS)
        try saveToKeychain(service: accessKeyService, value: accessKey)
        try saveToKeychain(service: secretKeyService, value: secretKey)
        
        SecurityLogger.shared.logCredentialsSaved()
    }
    
    func getCredentials() -> (accessKey: String, secretKey: String, region: String)? {
        guard let accessKey = getFromKeychain(service: accessKeyService),
              let secretKey = getFromKeychain(service: secretKeyService) else {
            return nil
        }
        return (accessKey, secretKey, lockedRegion)
    }
    
    func hasCredentials() -> Bool {
        return getCredentials() != nil
    }
    
    func clearCredentials() {
        deleteFromKeychain(service: accessKeyService)
        deleteFromKeychain(service: secretKeyService)
        
        SecurityLogger.shared.logCredentialsCleared()
    }
    
    // MARK: - Keychain Helpers
    
    private func saveToKeychain(service: String, value: String) throws {
        let data = value.data(using: .utf8)!
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlocked
        ]
        
        // Delete existing
        SecItemDelete(query as CFDictionary)
        
        // Add new
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw NSError(domain: "Keychain", code: Int(status), userInfo: [
                NSLocalizedDescriptionKey: "Failed to save to Keychain (status: \(status))"
            ])
        }
    }
    
    private func getFromKeychain(service: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess,
              let data = result as? Data,
              let value = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        return value
    }
    
    private func deleteFromKeychain(service: String) {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service
        ]
        SecItemDelete(query as CFDictionary)
    }
}
```

---

## **STEP 5: AWS Bedrock Integration with Security**

### **5.1: Create BedrockService**
```swift
// Services/BedrockService.swift
import Foundation
import CryptoKit

class BedrockService: NSObject {
    static let shared = BedrockService()
    
    private let modelId = "anthropic.claude-sonnet-4-5-v2:0"
    
    // SECURITY: Configure secure URLSession
    private lazy var urlSession: URLSession = {
        let config = URLSessionConfiguration.default
        
        // Enforce TLS 1.2 minimum
        config.tlsMinimumSupportedProtocolVersion = .TLSv12
        
        // Set timeout for large documents
        config.timeoutIntervalForRequest = 120  // 2 minutes
        
        // SECURITY: Disable caching of sensitive data
        config.urlCache = nil
        config.requestCachePolicy = .reloadIgnoringLocalCacheData
        
        // No cookies
        config.httpCookieStorage = nil
        config.httpCookieAcceptPolicy = .never
        
        return URLSession(configuration: config, delegate: self, delegateQueue: nil)
    }()
    
    override private init() {
        super.init()
    }
    
    func sendMessage(
        documentType: DocumentType,
        deidentifiedText: String,
        conversationHistory: [ClaudeMessage],
        userCustomInstructions: String?,
        userStylePreferences: String?,
        useContextEditing: Bool = false
    ) async throws -> String {
        
        guard let credentials = AWSCredentialsManager.shared.getCredentials() else {
            throw BedrockError.noCredentials
        }
        
        // Build system prompt
        var systemPrompt = documentType.systemPrompt
        
        // Add user style preferences if available
        if let preferences = userStylePreferences, !preferences.isEmpty {
            systemPrompt += "\n\nUser preferences: \(preferences)"
        }
        
        // Build messages array for Bedrock
        var messages: [[String: Any]] = []
        
        // First message includes the de-identified document with caching
        if conversationHistory.isEmpty {
            // First request - include document with cache
            let userContent: [[String: Any]] = [
                [
                    "type": "text",
                    "text": deidentifiedText,
                    "cache_control": ["type": "ephemeral"]
                ],
                [
                    "type": "text",
                    "text": userCustomInstructions ?? "Please process this document according to the instructions."
                ]
            ]
            
            messages.append([
                "role": "user",
                "content": userContent
            ])
        } else {
            // Subsequent messages - build from history
            for message in conversationHistory {
                messages.append([
                    "role": message.role.rawValue,
                    "content": message.content
                ])
            }
        }
        
        // Build request body
        var requestBody: [String: Any] = [
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "temperature": 1.0,
            "system": [[
                "type": "text",
                "text": systemPrompt,
                "cache_control": ["type": "ephemeral"]
            ]],
            "messages": messages
        ]
        
        // Add context editing if needed (for long conversations)
        if useContextEditing {
            requestBody["anthropic_beta"] = ["context-management-2025-06-27"]
            requestBody["context_management"] = [
                "clear_tool_uses_20250919": [
                    "trigger": ["input_tokens": 100000],
                    "keep": 3,
                    "clear_at_least": 10000
                ]
            ]
        }
        
        // SECURITY: Create request to Sydney region only
        let endpoint = "https://bedrock-runtime.\(credentials.region).amazonaws.com/model/\(modelId)/invoke"
        
        guard credentials.region == "ap-southeast-2" else {
            throw BedrockError.invalidRegion
        }
        
        let bodyData = try JSONSerialization.data(withJSONObject: requestBody)
        
        var request = URLRequest(url: URL(string: endpoint)!)
        request.httpMethod = "POST"
        request.httpBody = bodyData
        
        // SECURITY: Sign request with AWS Signature V4
        try signRequest(&request, with: credentials, body: bodyData)
        
        // Log request (metadata only)
        let estimatedTokens = deidentifiedText.count / 4  // Rough estimate
        SecurityLogger.shared.logBedrockRequest(
            tokenCount: estimatedTokens,
            documentType: documentType.rawValue
        )
        
        // Send request (encrypted via TLS 1.2+)
        let (data, response) = try await urlSession.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            SecurityLogger.shared.logBedrockResponse(tokenCount: 0, success: false)
            throw BedrockError.invalidResponse
        }
        
        guard httpResponse.statusCode == 200 else {
            let errorBody = String(data: data, encoding: .utf8) ?? "Unknown error"
            SecurityLogger.shared.logBedrockResponse(tokenCount: 0, success: false)
            throw BedrockError.apiError(statusCode: httpResponse.statusCode, message: errorBody)
        }
        
        // Parse response
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let content = json["content"] as? [[String: Any]] else {
            SecurityLogger.shared.logBedrockResponse(tokenCount: 0, success: false)
            throw BedrockError.invalidResponse
        }
        
        // Extract text from response
        var responseText = ""
        for block in content {
            if let type = block["type"] as? String, type == "text",
               let text = block["text"] as? String {
                responseText += text
            }
        }
        
        // Log response (metadata only)
        if let usage = json["usage"] as? [String: Any],
           let outputTokens = usage["output_tokens"] as? Int {
            SecurityLogger.shared.logBedrockResponse(tokenCount: outputTokens, success: true)
        }
        
        return responseText
    }
    
    // MARK: - AWS Signature V4
    
    private func signRequest(
        _ request: inout URLRequest,
        with credentials: (accessKey: String, secretKey: String, region: String),
        body: Data
    ) throws {
        let service = "bedrock"
        let algorithm = "AWS4-HMAC-SHA256"
        
        let now = Date()
        let dateFormatter = ISO8601DateFormatter()
        dateFormatter.formatOptions = [.withFullDate, .withTime, .withTimeZone]
        let amzDate = dateFormatter.string(from: now)
            .replacingOccurrences(of: "-", with: "")
            .replacingOccurrences(of: ":", with: "")
            .components(separatedBy: ".")[0] + "Z"
        let dateStamp = String(amzDate.prefix(8))
        
        // Hash body
        let bodyHash = SHA256.hash(data: body)
        let bodyHashHex = bodyHash.map { String(format: "%02x", $0) }.joined()
        
        // Set headers
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(bodyHashHex, forHTTPHeaderField: "x-amz-content-sha256")
        request.setValue(amzDate, forHTTPHeaderField: "x-amz-date")
        
        // Create canonical request
        let canonicalHeaders = """
        content-type:application/json
        host:\(request.url!.host!)
        x-amz-content-sha256:\(bodyHashHex)
        x-amz-date:\(amzDate)
        
        """
        
        let signedHeaders = "content-type;host;x-amz-content-sha256;x-amz-date"
        
        let canonicalRequest = """
        \(request.httpMethod!)
        \(request.url!.path)
        \(request.url!.query ?? "")
        \(canonicalHeaders)
        \(signedHeaders)
        \(bodyHashHex)
        """
        
        let canonicalRequestHash = SHA256.hash(data: canonicalRequest.data(using: .utf8)!)
        let canonicalRequestHashHex = canonicalRequestHash.map { String(format: "%02x", $0) }.joined()
        
        // Create string to sign
        let credentialScope = "\(dateStamp)/\(credentials.region)/\(service)/aws4_request"
        let stringToSign = """
        \(algorithm)
        \(amzDate)
        \(credentialScope)
        \(canonicalRequestHashHex)
        """
        
        // Calculate signature
        let kDate = hmac(key: "AWS4\(credentials.secretKey)".data(using: .utf8)!, message: dateStamp.data(using: .utf8)!)
        let kRegion = hmac(key: kDate, message: credentials.region.data(using: .utf8)!)
        let kService = hmac(key: kRegion, message: service.data(using: .utf8)!)
        let kSigning = hmac(key: kService, message: "aws4_request".data(using: .utf8)!)
        let signature = hmac(key: kSigning, message: stringToSign.data(using: .utf8)!)
        let signatureHex = signature.map { String(format: "%02x", $0) }.joined()
        
        // Set authorization header
        let authHeader = "\(algorithm) Credential=\(credentials.accessKey)/\(credentialScope), SignedHeaders=\(signedHeaders), Signature=\(signatureHex)"
        request.setValue(authHeader, forHTTPHeaderField: "Authorization")
    }
    
    private func hmac(key: Data, message: Data) -> Data {
        var hmac = HMAC<SHA256>(key: SymmetricKey(data: key))
        hmac.update(data: message)
        return Data(hmac.finalize())
    }
}

// MARK: - URLSessionDelegate for Certificate Validation

extension BedrockService: URLSessionDelegate {
    func urlSession(
        _ session: URLSession,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
    ) {
        // SECURITY: Validate AWS certificate
        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,
              let serverTrust = challenge.protectionSpace.serverTrust else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        // Check if host is AWS Bedrock Sydney
        let host = challenge.protectionSpace.host
        if host == "bedrock-runtime.ap-southeast-2.amazonaws.com" {
            // Accept valid AWS certificates
            let credential = URLCredential(trust: serverTrust)
            completionHandler(.useCredential, credential)
        } else {
            // Reject any other hosts
            completionHandler(.cancelAuthenticationChallenge, nil)
        }
    }
}

enum BedrockError: LocalizedError {
    case noCredentials
    case invalidResponse
    case invalidRegion
    case apiError(statusCode: Int, message: String)
    
    var errorDescription: String? {
        switch self {
        case .noCredentials:
            return "AWS credentials not configured. Please add credentials in Settings."
        case .invalidResponse:
            return "Invalid response from Bedrock"
        case .invalidRegion:
            return "Security error: Only Sydney region (ap-southeast-2) is permitted"
        case .apiError(let code, let message):
            return "Bedrock API error (\(code)): \(message)"
        }
    }
}
```

---

## **STEP 6: UI Components**

### **6.1: Add "Send to Claude" Button**
```swift
// Add to your main view where Window 2 (de-identified text) is shown

Button("Send to Claude") {
    // SECURITY: Validate redaction before proceeding
    do {
        try SessionManager.shared.validateRedactionComplete()
        
        // Check credentials
        if !AWSCredentialsManager.shared.hasCredentials() {
            showAWSSettings = true
        } else if SessionManager.shared.documentType == nil {
            showDocumentTypePicker = true
        } else {
            SessionManager.shared.isClaudeModalPresented = true
        }
    } catch {
        alertMessage = error.localizedDescription
        showAlert = true
    }
}
.disabled(SessionManager.shared.deidentifiedText == nil)
.alert("Validation Error", isPresented: $showAlert) {
    Button("OK", role: .cancel) {}
} message: {
    Text(alertMessage)
}
```

### **6.2: Document Type Picker Sheet**
```swift
// Views/DocumentTypePickerView.swift

struct DocumentTypePickerView: View {
    @Environment(\.dismiss) var dismiss
    @ObservedObject var sessionManager = SessionManager.shared
    @State private var selectedType: DocumentType?
    @State private var customInstructions: String = ""
    @State private var userStylePrefs: String = ""
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Select Document Type")
                .font(.title)
            
            Picker("Document Type", selection: $selectedType) {
                Text("Select...").tag(nil as DocumentType?)
                ForEach(DocumentType.allCases, id: \.self) { type in
                    Text(type.rawValue).tag(type as DocumentType?)
                }
            }
            .pickerStyle(.menu)
            
            if selectedType != nil {
                // User style preferences
                VStack(alignment: .leading) {
                    Text("Your Style Preferences (Optional)")
                        .font(.headline)
                    Text("e.g., 'I prefer brief bullet points' or 'Always use formal tone'")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    TextEditor(text: $userStylePrefs)
                        .frame(height: 60)
                        .border(Color.gray.opacity(0.3))
                }
                .onAppear {
                    if let type = selectedType {
                        userStylePrefs = PreferencesManager.shared.getUserStyle(for: type)
                    }
                }
                .onChange(of: selectedType) { newType in
                    if let type = newType {
                        userStylePrefs = PreferencesManager.shared.getUserStyle(for: type)
                    }
                }
                
                // Custom instructions for this specific document
                VStack(alignment: .leading) {
                    Text("Instructions for This Document (Optional)")
                        .font(.headline)
                    Text("Specific instructions for this document only")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    TextEditor(text: $customInstructions)
                        .frame(height: 80)
                        .border(Color.gray.opacity(0.3))
                }
            }
            
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                
                Button("Continue") {
                    guard let type = selectedType else { return }
                    
                    // Save preferences (non-sensitive, UserDefaults OK)
                    if !userStylePrefs.isEmpty {
                        PreferencesManager.shared.setUserStyle(userStylePrefs, for: type)
                    }
                    
                    // Set in session (in-memory only)
                    sessionManager.documentType = type
                    sessionManager.isDocumentTypeLocked = true
                    sessionManager.userCustomInstructions = customInstructions
                    
                    dismiss()
                    
                    // Open Claude modal
                    sessionManager.isClaudeModalPresented = true
                }
                .disabled(selectedType == nil)
                .buttonStyle(.borderedProminent)
            }
        }
        .padding()
        .frame(width: 500)
    }
}
```

### **6.3: Claude Chat Modal with Security Warning**
```swift
// Views/ClaudeModalView.swift

struct ClaudeModalView: View {
    @Environment(\.dismiss) var dismiss
    @ObservedObject var sessionManager = SessionManager.shared
    @State private var currentMessage: String = ""
    @State private var displayedResponse: String = ""
    @State private var errorMessage: String?
    @State private var showSecurityWarning: Bool = false
    @State private var hasAcceptedWarning: Bool = false
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Image(systemName: "lock.shield.fill")
                    .foregroundColor(.green)
                Text("Claude Assistant (Encrypted)")
                    .font(.title2)
                    .bold()
                Spacer()
                Button("Close") {
                    dismiss()
                }
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            
            // Chat history
            ScrollViewReader { proxy in
                ScrollView {
                    VStack(alignment: .leading, spacing: 16) {
                        ForEach(Array(sessionManager.conversationHistory.enumerated()), id: \.offset) { index, message in
                            ChatMessageView(message: message)
                                .id(index)
                        }
                        
                        // Show current response while processing
                        if sessionManager.isProcessing && !displayedResponse.isEmpty {
                            ChatMessageView(
                                message: ClaudeMessage(role: .assistant, content: displayedResponse)
                            )
                            .opacity(0.7)
                        }
                        
                        if let error = errorMessage {
                            HStack {
                                Image(systemName: "exclamationmark.triangle.fill")
                                    .foregroundColor(.red)
                                Text(error)
                                    .foregroundColor(.red)
                            }
                            .padding()
                        }
                    }
                    .padding()
                }
                .onChange(of: sessionManager.conversationHistory.count) { _ in
                    if let lastIndex = sessionManager.conversationHistory.indices.last {
                        withAnimation {
                            proxy.scrollTo(lastIndex, anchor: .bottom)
                        }
                    }
                }
            }
            
            Divider()
            
            // Input area
            HStack(alignment: .bottom, spacing: 12) {
                TextEditor(text: $currentMessage)
                    .frame(minHeight: 40, maxHeight: 100)
                    .border(Color.gray.opacity(0.3))
                    .disabled(sessionManager.isProcessing)
                
                VStack(spacing: 8) {
                    Button(sessionManager.conversationHistory.isEmpty ? "Send" : "Refine") {
                        sendMessage()
                    }
                    .disabled(currentMessage.isEmpty || sessionManager.isProcessing)
                    .buttonStyle(.borderedProminent)
                    
                    if !sessionManager.conversationHistory.isEmpty {
                        Button("Accept") {
                            acceptAndClose()
                        }
                        .disabled(sessionManager.isProcessing)
                        .buttonStyle(.bordered)
                    }
                }
            }
            .padding()
        }
        .frame(width: 700, height: 600)
        .alert("Security Confirmation", isPresented: $showSecurityWarning) {
            Button("Cancel", role: .cancel) {
                dismiss()
            }
            Button("Send Securely") {
                SecurityLogger.shared.logSecurityWarningAccepted()
                hasAcceptedWarning = true
                sendInitialMessage()
            }
        } message: {
            Text("""
            De-identified text will be sent to AWS Bedrock (Sydney) over encrypted connection.
            
            âœ“ All personal information replaced with codes
            âœ“ Data encrypted in transit (TLS 1.2+)
            âœ“ Processing in Sydney, Australia only
            âœ“ No data stored by AWS after processing
            
            Continue?
            """)
        }
        .onAppear {
            if sessionManager.conversationHistory.isEmpty && !hasAcceptedWarning {
                SecurityLogger.shared.logSecurityWarningShown()
                showSecurityWarning = true
            } else if sessionManager.conversationHistory.isEmpty {
                sendInitialMessage()
            }
        }
    }
    
    private func sendInitialMessage() {
        Task {
            await performSend(isInitial: true)
        }
    }
    
    private func sendMessage() {
        Task {
            await performSend(isInitial: false)
        }
    }
    
    private func performSend(isInitial: Bool) async {
        guard let deidentifiedText = sessionManager.deidentifiedText,
              let documentType = sessionManager.documentType else {
            return
        }
        
        sessionManager.isProcessing = true
        errorMessage = nil
        
        // Add user message to history
        let userMessage = isInitial ? sessionManager.userCustomInstructions : currentMessage
        if !isInitial {
            sessionManager.addMessage(role: .user, content: userMessage)
        }
        
        do {
            // Get user style preferences (non-sensitive)
            let stylePrefs = PreferencesManager.shared.getUserStyle(for: documentType)
            
            // Determine if we need context editing (> 10 messages = long conversation)
            let useContextEditing = sessionManager.conversationHistory.count > 10
            
            // Send to Bedrock (encrypted via TLS 1.2+)
            let response = try await BedrockService.shared.sendMessage(
                documentType: documentType,
                deidentifiedText: deidentifiedText,
                conversationHistory: sessionManager.conversationHistory,
                userCustomInstructions: isInitial ? userMessage : nil,
                userStylePreferences: stylePrefs.isEmpty ? nil : stylePrefs,
                useContextEditing: useContextEditing
            )
            
            // SECURITY: Validate Claude preserved redaction codes
            try sessionManager.validateCodesPreserved(in: response)
            
            // Add assistant response to history
            await MainActor.run {
                sessionManager.addMessage(role: .assistant, content: response)
                displayedResponse = response
                currentMessage = ""
            }
            
        } catch {
            await MainActor.run {
                errorMessage = error.localizedDescription
            }
        }
        
        await MainActor.run {
            sessionManager.isProcessing = false
        }
    }
    
    private func acceptAndClose() {
        // Get the last assistant message
        guard let lastAssistant = sessionManager.conversationHistory.last(where: { $0.role == .assistant }) else {
            return
        }
        
        // Re-identify the text (happens locally)
        let reidentified = sessionManager.reidentify(text: lastAssistant.content)
        
        // Set as final text (in-memory only)
        sessionManager.finalText = reidentified
        
        // Close modal
        dismiss()
    }
}

struct ChatMessageView: View {
    let message: ClaudeMessage
    
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            if message.role == .assistant {
                Image(systemName: "sparkles")
                    .font(.title3)
                    .foregroundColor(.blue)
            } else {
                Image(systemName: "person.circle.fill")
                    .font(.title3)
                    .foregroundColor(.green)
            }
            
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(message.role == .assistant ? "Claude" : "You")
                        .font(.caption)
                        .bold()
                    
                    Spacer()
                    
                    Text(message.timestamp, style: .time)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                
                Text(message.content)
                    .textSelection(.enabled)
            }
            
            Spacer()
        }
        .padding()
        .background(message.role == .assistant ? Color.blue.opacity(0.1) : Color.green.opacity(0.1))
        .cornerRadius(8)
    }
}
```

---

## **STEP 7: AWS Settings View**

### **7.1: Secure AWS Configuration**
```swift
// Views/AWSSettingsView.swift

struct AWSSettingsView: View {
    @Environment(\.dismiss) var dismiss
    @State private var accessKey: String = ""
    @State private var secretKey: String = ""
    @State private var errorMessage: String?
    @State private var showSuccess: Bool = false
    @State private var showingCredentials: Bool = false
    
    // SECURITY: Region locked to Sydney
    private let lockedRegion = "ap-southeast-2"
    
    var body: some View {
        VStack(spacing: 20) {
            HStack {
                Image(systemName: "lock.shield.fill")
                    .font(.largeTitle)
                    .foregroundColor(.blue)
                
                VStack(alignment: .leading) {
                    Text("AWS Bedrock Configuration")
                        .font(.title)
                    Text("Credentials stored securely in macOS Keychain")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Divider()
            
            // Region info (locked, not editable)
            HStack {
                VStack(alignment: .leading) {
                    Text("AWS Region")
                        .font(.headline)
                    Text("Sydney, Australia (ap-southeast-2)")
                        .foregroundColor(.secondary)
                }
                Spacer()
                Image(systemName: "lock.fill")
                    .foregroundColor(.green)
            }
            .padding()
            .background(Color.green.opacity(0.1))
            .cornerRadius(8)
            
            Text("Region is locked to Sydney for NZ data residency compliance")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Divider()
            
            // Credentials input
            VStack(alignment: .leading, spacing: 8) {
                Text("AWS Access Key ID")
                    .font(.headline)
                TextField("AKIA...", text: $accessKey)
                    .textFieldStyle(.roundedBorder)
                    .disabled(showingCredentials)
            }
            
            VStack(alignment: .leading, spacing: 8) {
                Text("AWS Secret Access Key")
                    .font(.headline)
                SecureField("Secret Key", text: $secretKey)
                    .textFieldStyle(.roundedBorder)
                    .disabled(showingCredentials)
            }
            
            if let error = errorMessage {
                HStack {
                    Image(systemName: "exclamationmark.triangle.fill")
                    Text(error)
                }
                .foregroundColor(.red)
                .font(.caption)
            }
            
            if showSuccess {
                HStack {
                    Image(systemName: "checkmark.circle.fill")
                    Text("Credentials saved successfully to Keychain")
                }
                .foregroundColor(.green)
            }
            
            Spacer()
            
            // Buttons
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                
                if AWSCredentialsManager.shared.hasCredentials() {
                    Button("Clear Credentials") {
                        AWSCredentialsManager.shared.clearCredentials()
                        showSuccess = false
                        showingCredentials = false
                        accessKey = ""
                        secretKey = ""
                    }
                    .foregroundColor(.red)
                }
                
                Spacer()
                
                Button("Save to Keychain") {
                    saveCredentials()
                }
                .disabled(accessKey.isEmpty || secretKey.isEmpty || showingCredentials)
                .buttonStyle(.borderedProminent)
            }
        }
        .padding()
        .frame(width: 550)
        .onAppear {
            if AWSCredentialsManager.shared.hasCredentials() {
                // Show that credentials exist (but don't show actual values)
                showingCredentials = true
                accessKey = "Credentials saved in Keychain"
                secretKey = "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            }
        }
    }
    
    private func saveCredentials() {
        do {
            // SECURITY: Credentials saved to encrypted Keychain
            try AWSCredentialsManager.shared.saveCredentials(
                accessKey: accessKey,
                secretKey: secretKey
            )
            showSuccess = true
            errorMessage = nil
            showingCredentials = true
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                dismiss()
            }
        } catch {
            errorMessage = error.localizedDescription
        }
    }
}
```

---

## **STEP 8: Wire Everything Together**

### **8.1: Update Main View**
```swift
// In your main ContentView or wherever the 3 windows are

@ObservedObject var sessionManager = SessionManager.shared
@State private var showDocumentTypePicker = false
@State private var showAWSSettings = false
@State private var showAlert = false
@State private var alertMessage = ""

var body: some View {
    // ... your existing three windows ...
    
    // After Window 2 (de-identified text)
    Button("Send to Claude (Encrypted)") {
        // SECURITY: Validate redaction
        do {
            try sessionManager.validateRedactionComplete()
            
            if !AWSCredentialsManager.shared.hasCredentials() {
                showAWSSettings = true
            } else if sessionManager.documentType == nil {
                showDocumentTypePicker = true
            } else {
                sessionManager.isClaudeModalPresented = true
            }
        } catch {
            alertMessage = error.localizedDescription
            showAlert = true
        }
    }
    .disabled(sessionManager.deidentifiedText == nil)
    
    // Window 3 - automatically updates when finalText is set
    VStack {
        Text("Final Text (Re-identified)")
            .font(.headline)
        
        if let finalText = sessionManager.finalText {
            TextEditor(text: .constant(finalText))
                .frame(minHeight: 200)
        } else {
            Text("Processed text will appear here")
                .foregroundColor(.secondary)
                .frame(minHeight: 200)
        }
    }
    
    // Clear button (clears all in-memory data)
    Button("Clear All") {
        sessionManager.clearSession()
        // Also clear your existing anonymization data
    }
    .foregroundColor(.red)
    
    // Modals
    .sheet(isPresented: $showDocumentTypePicker) {
        DocumentTypePickerView()
    }
    .sheet(isPresented: $sessionManager.isClaudeModalPresented) {
        ClaudeModalView()
    }
    .sheet(isPresented: $showAWSSettings) {
        AWSSettingsView()
    }
    .alert("Validation Error", isPresented: $showAlert) {
        Button("OK", role: .cancel) {}
    } message: {
        Text(alertMessage)
    }
}
```

### **8.2: Add Settings Menu Item**
```swift
// In your App file or menu bar

Settings {
    AWSSettingsView()
}

// Or add a preferences button
Button("AWS Settings...") {
    showAWSSettings = true
}
```

---

## **STEP 9: Testing & Validation**

### **9.1: Security Testing Checklist**

```
CREDENTIALS & CONFIGURATION
â–¡ AWS credentials save to Keychain successfully
â–¡ AWS credentials cannot be retrieved by other apps
â–¡ Region locked to ap-southeast-2 (Sydney)
â–¡ User cannot change region in UI
â–¡ Clear credentials removes from Keychain completely

REDACTION VALIDATION
â–¡ Validation catches incomplete redaction (original text still present)
â–¡ Validation passes when redaction complete
â–¡ Validation catches if Claude removes codes
â–¡ Error messages are clear and actionable

NETWORK SECURITY
â–¡ All requests go to Sydney endpoint only
â–¡ Requests use HTTPS (TLS 1.2+)
â–¡ Certificate validation works correctly
â–¡ Invalid certificates rejected
â–¡ Requests to other regions fail
â–¡ Timeout works for large documents

DATA HANDLING
â–¡ De-identified text contains no original names
â–¡ Redaction codes ([PERSON_A], etc.) preserved in Claude response
â–¡ Re-identification correctly swaps codes back
â–¡ No data written to disk (except Keychain)
â–¡ Session data cleared on "Clear All"
â–¡ No data persists after app quit

CONVERSATION FLOW
â–¡ Security warning shows on first send
â–¡ User can cancel from security warning
â–¡ Document type selection works
â–¡ User style preferences save (UserDefaults)
â–¡ Custom instructions included in first message
â–¡ Conversation history builds up correctly
â–¡ Context editing triggers after 10+ messages
â–¡ "Accept" button re-identifies correctly
â–¡ Final text appears in Window 3

ERROR HANDLING
â–¡ Missing credentials shows appropriate error
â–¡ Invalid credentials shows appropriate error
â–¡ Network errors handled gracefully
â–¡ Timeout errors show helpful message
â–¡ API errors display to user
â–¡ Validation errors prevent sending

LOGGING
â–¡ Security logger records metadata only
â–¡ No sensitive content in logs
â–¡ Timestamps correct
â–¡ All security events logged
```

### **9.2: Test Scenarios**

**Scenario 1: First-time setup**
```
1. Open app (no credentials)
2. Try to send â†’ Shows AWS settings
3. Enter credentials â†’ Saves to Keychain
4. Try to send â†’ Shows document type picker
5. Select type â†’ Shows security warning
6. Accept â†’ Sends to Bedrock
7. Response appears in modal
8. Accept â†’ Re-identified text in Window 3
```

**Scenario 2: Incomplete redaction**
```
1. Paste text with "John Smith"
2. De-identify (but suppose it misses one)
3. Try to send â†’ Validation error
4. Fix redaction
5. Send again â†’ Success
```

**Scenario 3: Multi-turn refinement**
```
1. Send initial document
2. Refine: "Make it shorter"
3. Refine: "Add more detail to section 2"
4. Refine: "Use bullet points"
5. Check conversation history has all messages
6. Check context editing triggers after 10 turns
7. Accept final version
```

**Scenario 4: Session management**
```
1. Process document â†’ Accept
2. Click "Clear All"
3. Verify all windows cleared
4. Verify can process new document
5. Quit app and reopen
6. Verify credentials still in Keychain
7. Verify no conversation data persists
```

---

## **STEP 10: Documentation**

### **10.1: Internal Documentation**

```markdown
# Claude Integration Security Architecture

## Data Flow

1. **Local De-identification**
   - User pastes original text
   - App replaces identifiers with codes
   - Mapping stored in-memory only

2. **Encrypted Transmission**
   - De-identified text sent to AWS Bedrock
   - TLS 1.2+ encryption
   - Sydney region only (ap-southeast-2)
   - AWS Signature V4 authentication

3. **Processing**
   - Bedrock processes request
   - No data stored after response
   - Prompt caching (5 min max)

4. **Local Re-identification**
   - Improved text received
   - Codes swapped back to original values
   - Final text displayed

## Storage

### Keychain (Encrypted)
- AWS Access Key
- AWS Secret Key

### UserDefaults (Non-sensitive)
- User style preferences per document type

### Memory Only (Cleared on quit)
- Original text
- De-identified text
- Entity mappings
- Conversation history
- Final re-identified text

### No Storage
- No database
- No disk files (except preferences)
- No logs with content
- No cloud storage

## Security Measures

1. **Region Lock**: ap-southeast-2 only
2. **TLS 1.2+**: All API calls encrypted
3. **Certificate Validation**: AWS certs only
4. **Redaction Validation**: Before send, after receive
5. **Security Warning**: User acknowledgment required
6. **Keychain Storage**: OS-level encryption
7. **No Caching**: URLSession caching disabled
8. **Logging**: Metadata only, no content

## Compliance

- Data processed in Australia (Sydney)
- No persistent storage of health information
- User controls all data lifecycle
- Audit trail via security logging
- No third-party data sharing
```

---

## **Implementation Timeline**

### **For AI Coder: 5-Day Sprint**

**Day 1: Foundation**
- Step 1: Data models (ClaudeMessage, DocumentType, SessionManager)
- Step 2: PreferencesManager
- Step 3: SecurityLogger
- Testing: Models compile and work

**Day 2: Security & Credentials**
- Step 4: AWSCredentialsManager (Keychain)
- Step 7: AWSSettingsView
- Testing: Credentials save/retrieve/clear

**Day 3: Bedrock Integration**
- Step 5: BedrockService (TLS, signing, validation)
- Testing: Can send/receive from Bedrock

**Day 4: UI Components**
- Step 6.1-6.2: Document type picker
- Step 6.3: Claude modal with security warning
- Testing: Full flow works

**Day 5: Integration & Testing**
- Step 8: Wire everything together
- Step 9: Run full test suite
- Step 10: Document any issues

---

## **Critical Success Factors**

âœ… **Security First**: Every step validates and protects data
âœ… **Sydney Only**: No data leaves Australia/NZ region
âœ… **No Persistence**: Session data only, cleared on quit
âœ… **User Control**: Explicit warnings and confirmations
âœ… **Audit Trail**: Security logging for accountability

Does this updated plan address all your security concerns? Ready for the AI coder to implement?